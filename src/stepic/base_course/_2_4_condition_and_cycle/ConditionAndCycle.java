package stepic.base_course._2_4_condition_and_cycle;

import java.math.BigInteger;

public class ConditionAndCycle {
    public static void main(String[] args) {

        System.out.println((printTextPerRole(
                new String[]{"Городничий", "Аммос Федорович", "Артемий Филиппович", "Лука Лукич"},
                new String[]{"Городничий: Я пригласил вас.",
                        "Аммос Федорович: Как ревизор?",
                        "Артемий Филиппович: Как ревизор?",
                        "Городничий: Ревизор из Петербурга.",
                        "Аммос Федорович: Вот те на!",
                        "Артемий Филиппович: Вот не было заботы, так подай!",
                        "Лука Лукич: Господи боже! еще и с секретным предписаньем!"})));

    }

    /**
     * Реализуйте метод, вычисляющий факториал заданного натурального числа.
     * Факториал N вычисляется как 1 * 2 * 3 * ... * N
     * Поскольку это очень быстро растущая функция,
     * то даже для небольших N вместимости типов int и long очень скоро не хватит.
     * Поэтому будем использовать BigInteger.
     * Sample Input:
     * 1
     * Sample Output:
     * 1
     * -------------
     * Sample Input:
     * 3
     * Sample Output:
     * 6
     */
    // 1*2*3=6          2 432 902 008 176 640 000
    public static BigInteger factorial(int value) {
        BigInteger res = BigInteger.ONE;
        for (int i = 1; i <= value; i++) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return new BigInteger(String.valueOf(res));
    }

    /**
     * - Реализуйте метод, сливающий два отсортированных по возрастанию массива чисел в один
     * отсортированный в том же порядке массив. Массивы могут быть любой длины, в том числе
     * нулевой.
     * - Предполагается, что вы реализуете алгоритм слияния, имеющий линейную сложность: он
     * будет идти по двум исходным массивам и сразу формировать отсортированный результирующий
     * массив. Так, чтобы сортировка полученного массива при помощи Arrays.sort() уже не
     * требовалась. К сожалению, автоматически это не проверить, так что это остается на вашей
     * совести :)
     * - Если на вход подаются массивы {0, 2, 2} и {1, 3},
     * то на выходе должен получиться массив {0, 1, 2, 2, 3}
     *
     * @param first
     */
    public static int[] mergeArrays(int[] first, int[] second) {
        int sum = first.length + second.length;
        int[] result = new int[sum];
        int iF = 0;
        int iS = 0;

        for (int i = 0; i < result.length; i++) {
            if (iS == second.length || iF != first.length && first[iF] < second[iS]) {
                result[i] = first[iF];
                iF += 1;
            } else {
                result[i] = second[iS];
                iS += 1;
            }
        }

        return result;
    }


    /**
     * Вам дан список ролей и сценарий пьесы в виде массива строк.
     * Каждая строчка сценария пьесы дана в следующем виде:
     * Роль: текст.   Текст может содержать любые символы.
     * Напишите метод, который будет группировать строчки по ролям, пронумеровывать их и возвращать
     * результат в виде готового текста (см. пример). Каждая группа распечатывается в следующем виде:
     * Роль:
     * i) текст
     * j) текст2
     * ...
     * ==перевод строки==
     * i и j -- номера строк в сценарии. Индексация строчек начинается с единицы, выводить группы
     * следует в соответствии с порядком ролей. Переводы строк между группами обязательны, переводы
     * строк в конце текста не учитываются. Заметим, что вам предстоит обработка огромной пьесы в
     * 50 000 строк для 10 ролей – соответственно, неправильная сборка результирующей строчки может
     * выйти за ограничение по времени.
     * Обратите внимание еще на несколько нюансов:
     * имя персонажа может встречаться в строке более одного раза, в том числе с двоеточием;
     * название одной роли может быть префиксом названия другой роли (например, "Лука" и "Лука Лукич");
     * роль, у которой нет реплик, тоже должна присутствовать в выходном файле;
     * в качестве перевода строки надо использовать символ '\n' (перевод строки в стиле UNIX);
     * будьте внимательны, не добавляйте лишних пробелов в конце строк.
     * -
     * -Sample Input:
     * roles:     ["Городничий", "Аммос Федорович", "Артемий Филиппович", "Лука Лукич"]
     * textLines:
     * -       ["Городничий: Я пригласил вас, господа.",
     * -        "Аммос Федорович: Как ревизор?",
     * -        "Артемий Филиппович: Как ревизор?",
     * -        "Городничий: Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.",
     * -        "Аммос Федорович: Вот те на!",
     * -        "Артемий Филиппович: Вот не было заботы, так подай!",
     * -        "Лука Лукич: Господи боже! еще и с секретным предписаньем!"]
     * -
     * -Sample Output:
     * -       "Городничий:
     * -        1) Я пригласил вас, господа.
     * -        4) Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.
     * -
     * -        Аммос Федорович:
     * -        2) Как ревизор?
     * -        5) Вот те на!
     * -
     * -        Артемий Филиппович:
     * -        3) Как ревизор?
     * -        6) Вот не было заботы, так подай!
     * -
     * -        Лука Лукич:
     * -        7) Господи боже! еще и с секретным предписаньем!"
     */

    public static String printTextPerRole(String[] roles, String[] textLines) {
//        StringBuilder result = new StringBuilder();
//
//        for (String name : roles) {
//            result.append(name).append(":").append("\n");
//            for (int j = 0; j < textLines.length; j++) {
//                if (textLines[j].startsWith(name + ":")) {
//                    result.append(j + 1)
//                            .append(")")
//                            .append(textLines[j].replaceFirst(name + ":", ""))
//                            .append("\n");
//                }
//            }
//            result.append("\n");
//        }
//
//        return result.toString();

        String result = "";

        for (String name : roles) {
            result += name + ":" + "\n";

            for (int iT = 0; iT < textLines.length; iT++) {

                if (textLines[iT].startsWith(name + ":")) {
                    result += (iT + 1) + ")"
                            + textLines[iT].replaceFirst(name + ":", "")
                            + "\n";
                }
            }
            result += "\n";

        }

        return result;


    }

}